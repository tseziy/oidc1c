#Область ОписаниеПеременных

// Служебные зависимости
Перем
_Http Экспорт,
_ХостIdentity Экспорт,
_РесурсКодУстройства Экспорт,
_РесурсТокен Экспорт,
Имя Экспорт,
Ключ Экспорт,
Скоупы Экспорт;

#КонецОбласти

#Область Интерфейс

// Определения

Функция МодельЗапрос() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Хост");
	Результат.Вставить("Ресурс");
	Результат.Вставить("Тело");
	Результат.Вставить("Метод");
	Результат.Вставить("Заголовки");
	
	Возврат Результат;
	
КонецФункции

Функция МодельОтветДевайсКод() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Код");
	Результат.Вставить("КодПользователя");
	Результат.Вставить("Ссылка");
	Результат.Вставить("СсылкаАвторизации");
	Результат.Вставить("Интервал");
	Результат.Вставить("ВремяЖизни", 0);
	Результат.Вставить("УниверсальнаяДатаОкончания", Дата(1, 1, 1));
	Результат.Вставить("УниверсальнаяДатаОкончанияМС", 0);

	Возврат Результат;
	
КонецФункции

Функция МодельОтветТокен() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТокенДоступа");
	Результат.Вставить("ТокенОбновления");
	Результат.Вставить("ВремяЖизни", 0);
	Результат.Вставить("УниверсальнаяДатаОкончания", Дата(1, 1, 1));
	Результат.Вставить("УниверсальнаяДатаОкончанияМС", 0);
	Результат.Вставить("Тип");
	Результат.Вставить("Представление");
	Результат.Вставить("ПортальныйИдентификаторПользователя");
	
	Возврат Результат;
	
КонецФункции

Функция МодельРезультатЗапроса() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("КодСостояния");
	Результат.Вставить("Тело");
	Результат.Вставить("Заголовки");
	
	Возврат Результат;
	                                                                      
КонецФункции

// OIDC

Функция КодУстройства() Экспорт
	
	Возврат _КодУстройства();
	
КонецФункции

Функция Токен(КодУстройства) Экспорт
	
	Результат = _Токен(КодУстройства);
	
	Возврат Результат;
	
КонецФункции

Функция ОбновитьТокен(ТокенОбновления) Экспорт

	Результат = _ОбновитьТокен(ТокенОбновления);
	
	Возврат Результат;
	
КонецФункции

// Вспомогательные

Процедура УдалитьСессию(Ключ) Экспорт
	
	ХранилищеСистемныхНастроек.Сохранить(_КлючОбъектаАвторизация(), Ключ, Неопределено);	
	
КонецПроцедуры

Процедура УдалитьНастройку(Ключ) Экспорт
	
	Пользователь = ПользователиИнформационнойБазы.ТекущийПользователь();
	ХранилищеСистемныхНастроек.Удалить(_КлючОбъектаАвторизация(), Ключ, Пользователь.Имя);	
	
КонецПроцедуры

Процедура СохранитьСессию(Ключ, Сессия) Экспорт 
	
	Модель = МодельОтветТокен();
	
	ЗаполнитьЗначенияСвойств(Модель, Сессия);
	          
	Настройка = Новый ФиксированнаяСтруктура(Модель);
	ХранилищеСистемныхНастроек.Сохранить(_КлючОбъектаАвторизация(), Ключ, Настройка);
	
КонецПроцедуры

Функция СохраненнаяСессия(Ключ) Экспорт
	
	Значение = ХранилищеСистемныхНастроек.Загрузить(_КлючОбъектаАвторизация(), Ключ);
	Если ТипЗнч(Значение) <> Тип("ФиксированнаяСтруктура") Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	Модель = МодельОтветТокен();	
	ЗаполнитьЗначенияСвойств(Модель, Значение);
	Сессия = Новый ФиксированнаяСтруктура(Модель);
	
	Возврат Сессия;
	
КонецФункции

Функция ПолучитьСессию(Ключ) Экспорт
	
	Сессия = СохраненнаяСессия(Ключ);	
	Если Сессия = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	СессияПротухла = ТекущаяУниверсальнаяДата() >= Сессия.УниверсальнаяДатаОкончания;	
	ОбновитьСессию = СессияПротухла И ЗначениеЗаполнено(Сессия.ТокенОбновления);

	Если ОбновитьСессию Тогда
		Результат = ОбновитьТокен(Сессия.ТокенОбновления);
		Если Результат.ТокенДоступа <> Неопределено Тогда
			СохранитьСессию(Ключ, Результат);
		КонецЕсли;
	ИначеЕсли СессияПротухла Тогда
		Результат = Неопределено;
	Иначе
		Результат = Сессия;	
	КонецЕсли;
	
	Возврат Результат;
		
КонецФункции

Функция ПолучитьСессии() Экспорт
	
	СписокНастроек = СписокНастроек();
	Результат = Новый Соответствие;
	
	Для Каждого Настройка Из СписокНастроек Цикл
		
		Попытка                      
			Сессия = ПолучитьСессию(Настройка.Значение);
			Если Сессия = Неопределено Тогда
				УдалитьНастройку(Настройка.Значение);	
			Иначе
				Результат.Вставить(Настройка.Значение, Сессия);	
			КонецЕсли;
		Исключение
			УдалитьНастройку(Настройка.Значение);
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СписокНастроек() Экспорт

	Возврат ХранилищеСистемныхНастроек.ПолучитьСписок(_КлючОбъектаАвторизация());
	
КонецФункции

#КонецОбласти

#Область ДевайсКод

Функция _КодУстройства() Экспорт
	
	Тело = ПолучитьДвоичныеДанныеИзСтроки(_КодироватьПараметрыЗапроса(_ДевайКодСформироватьПараметры()));
	Запрос = _ЗапросДевайсКод(Тело);
	Результат = _Http.Post(Запрос.Хост + Запрос.Ресурс, Запрос.Тело);
	Ответ = КакJson(Результат);
	
	Если Ответ.Получить("error") <> Неопределено Тогда
		ВызватьИсключение Ответ.Получить("error");
	КонецЕсли;
	
	Результат = _РазобратьОтветДевайсКод(Ответ);
	
	Возврат Новый ФиксированнаяСтруктура(Результат);
	
КонецФункции

Функция _ДевайКодСформироватьПараметры() 
	
	Результат = Новый Соответствие;
	Результат.Вставить("client_id", Имя);
	Результат.Вставить("client_secret", Ключ);
	Результат.Вставить("scope", Скоупы);
	
	Возврат Результат;
	
КонецФункции

Функция _РазобратьОтветДевайсКод(Ответ)
	
	Результат = МодельОтветДевайсКод();
	
	Результат.Код = Ответ.Получить("device_code");
	Результат.КодПользователя = Ответ.Получить("user_code");
	Результат.Ссылка = Ответ.Получить("verification_url");
	Результат.Интервал = Ответ.Получить("interval");
	Результат.ВремяЖизни = Ответ.Получить("expires_in");
	Если Ответ.Получить("verification_url") = Неопределено Тогда
		Результат.СсылкаАвторизации = Ответ.Получить("verification_uri");
	Иначе
		Результат.СсылкаАвторизации = Ответ.Получить("verification_url");
	КонецЕсли;
	Если Ответ.Получить("verification_uri_complete") = Неопределено Тогда
		Результат.СсылкаАвторизации = Результат.СсылкаАвторизации;
	Иначе
		Результат.СсылкаАвторизации = Ответ.Получить("verification_uri_complete");
	КонецЕсли;
	
	ВМиллисекундах = 1000;	
	Если ЗначениеЗаполнено(Результат.ВремяЖизни) Тогда
		Результат.УниверсальнаяДатаОкончания = ТекущаяУниверсальнаяДата() + Число(Результат.ВремяЖизни);
		Результат.УниверсальнаяДатаОкончанияМС = (Дата(1, 1, 1) - Результат.УниверсальнаяДатаОкончания) 
			* ВМиллисекундах * -1; 
	Иначе
		Результат.УниверсальнаяДатаОкончания = Дата(1, 1, 1);
		Результат.УниверсальнаяДатаОкончанияМС = 0;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Токен

Функция _Токен(КодУстройства)
	
	Тело = ПолучитьДвоичныеДанныеИзСтроки(_КодироватьПараметрыЗапроса(_ТокенСформироватьПараметры(КодУстройства)));
	Запрос = _ЗапросТокен(Тело);
	
	Результат = _Http.Post(Запрос.Хост + Запрос.Ресурс, Запрос.Тело);
	Ответ = КакJson(Результат);
	
	Если Ответ.Получить("error") <> Неопределено И Ответ.Получить("error") <> "authorization_pending" Тогда
		ВызватьИсключение Ответ.Получить("error");
	КонецЕсли;
	
	Результат = _ТокенРазобратьОтвет(Ответ); 
	Возврат Новый ФиксированнаяСтруктура(Результат);
	
КонецФункции

Функция _ТокенСформироватьПараметры(КодУстройства)
	
	Результат = Новый Соответствие;
	
	Результат.Вставить("grant_type", "device_code");
	Результат.Вставить("client_id", Имя);
	Результат.Вставить("client_secret", Ключ);		
	Результат.Вставить("code", КодУстройства);
	Результат.Вставить("scope", Скоупы);
	
	Возврат Результат;
	
КонецФункции

Функция _ТокенРазобратьОтвет(Ответ)
	
	Результат = МодельОтветТокен();
	
	ДанныеТокена = _КакJwt(Ответ.Получить("id_token"));
	
	Результат.ТокенДоступа = Ответ.Получить("access_token");
	Результат.ТокенОбновления = Ответ.Получить("refresh_token");
	Результат.ВремяЖизни = Ответ.Получить("expires_in");
	Результат.Тип = Ответ.Получить("token_type");
	Результат.Представление = _ПредставлениеПользователяПоТокенИд(ДанныеТокена);
	
	ВМиллисекундах = 1000;	
	Если ЗначениеЗаполнено(Результат.ВремяЖизни) Тогда
		Результат.УниверсальнаяДатаОкончания = ТекущаяУниверсальнаяДата() + Число(Результат.ВремяЖизни);
		Результат.УниверсальнаяДатаОкончанияМС = (Дата(1, 1, 1) - Результат.УниверсальнаяДатаОкончания) 
			* ВМиллисекундах * -1; 
	Иначе
		Результат.УниверсальнаяДатаОкончания = Дата(1, 1, 1);
		Результат.УниверсальнаяДатаОкончанияМС = 0;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

Функция _ПредставлениеПользователяПоТокенИд(Данные)
	
	Имя = Данные.Тело.Получить("name");
	Почта = Данные.Тело.Получить("email");
	
	Если ЗначениеЗаполнено(Почта) Тогда
	
		Результат = Почта;
		
		Если ЗначениеЗаполнено(Имя) Тогда
			
			Результат = Результат + " (" + Имя + ")";
			
		КонецЕсли;
		
	Иначе
		
		Результат = Имя;
	
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область РефрешТокен

Функция _ОбновитьТокен(ТокенОбновления)

	Тело = ПолучитьДвоичныеДанныеИзСтроки(
		_КодироватьПараметрыЗапроса(
		_ОбновитьТокенСформироватьПараметры(ТокенОбновления)));
	Запрос = _ЗапросТокен(Тело);
	
	Результат = _Http.Post(Запрос.Хост + Запрос.Ресурс, Запрос.Тело);
	Ответ = КакJson(Результат);
	
	Если Ответ.Получить("error") <> Неопределено И Ответ.Получить("error") <> "authorization_pending" Тогда
		ВызватьИсключение Ответ.Получить("error");
	КонецЕсли;
	
	Результат = _ТокенРазобратьОтвет(Ответ);
	Возврат Новый ФиксированнаяСтруктура(Результат);
	
КонецФункции

Функция _ОбновитьТокенСформироватьПараметры(ТокенОбновления)
	
	Результат = Новый Соответствие;
	
	Результат.Вставить("grant_type", "refresh_token");
	Результат.Вставить("client_id", Имя);
	Результат.Вставить("client_secret", Ключ);	
	Результат.Вставить("refresh_token", ТокенОбновления);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область HTTP

Функция Post(URL, Данные = Неопределено) Экспорт
	
	СтруктураURL = _РазобратьURL(URL);
	Соединение = _НовыйЗащищенноеСоединение(СтруктураURL.Сервер);	
	HttpЗапрос = _НовыйHTTPЗапрос(СтруктураURL.Путь, Данные);

	Ответ = Соединение.ВызватьHTTPМетод("POST", HttpЗапрос); 
	
	Результат = МодельРезультатЗапроса();
	Результат.КодСостояния = Ответ.КодСостояния;
	Результат.Заголовки = Ответ.Заголовки;
	Результат.Тело = Ответ.ПолучитьТелоКакДвоичныеДанные();
	
	Возврат Результат;
	
КонецФункции

Функция _НовыйЗащищенноеСоединение(URL)
	
	ЗащищенноеСоединение = Новый("ЗащищенноеСоединениеOpenSSL");
	Таймаут = 30;
	Соединение = Новый HTTPСоединение(URL,,,,, Таймаут, ЗащищенноеСоединение);
	
	Возврат Соединение;
	
КонецФункции

Функция _НовыйHTTPЗапрос(Ресурс, Тело)
	
	Результат = Новый HTTPЗапрос(Ресурс, _ЗаголовкиПоУмолчанию());
	
	Если ТипЗнч(Тело) = Тип("ДвоичныеДанные") Тогда
		Результат.УстановитьТелоИзДвоичныхДанных(Тело);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция _РазобратьURL(Знач URL)

	Схема = "";
	Путь = "";
	Аутентификация = Новый Структура("Пользователь, Пароль", "", "");
	Сервер = "";
	Порт = "";
	Фрагмент = "";
	
	ДопустимыеСхемы = СтрРазделить("http,https", ",");
	
	URLБезСхемы = URL;
	_РазбитьСтрокуПоРазделителю(Схема, URLБезСхемы, "://");
	Если ДопустимыеСхемы.Найти(НРег(Схема)) <> Неопределено Тогда
		URL = URLБезСхемы;
	Иначе
		Схема = "";
	КонецЕсли;
	
	Результат = _РазделитьПоПервомуНайденномуРазделителю(URL, СтрРазделить("/,?,#", ","));
	URL = Результат[0];
	Если ЗначениеЗаполнено(Результат[2]) Тогда
		Путь = Результат[2] + Результат[1];
	КонецЕсли;
	
	АутентификацияСтрока = "";
	_РазбитьСтрокуПоРазделителю(АутентификацияСтрока, URL, "@");
	Если ЗначениеЗаполнено(АутентификацияСтрока) Тогда
		АутентификацияЧасти = СтрРазделить(АутентификацияСтрока, ":");
		Аутентификация.Пользователь = АутентификацияЧасти[0];
		Аутентификация.Пароль       = АутентификацияЧасти[1];
	КонецЕсли;

	// IPv6
	_РазбитьСтрокуПоРазделителю(Сервер, URL, "]");
	Если ЗначениеЗаполнено(Сервер) Тогда
		Сервер = Сервер + "]";
	КонецЕсли;
	
	URL = СтрЗаменить(URL, "/", "");
	
	_РазбитьСтрокуПоРазделителю(Порт, URL, ":", Истина);
	
	Если Не ЗначениеЗаполнено(Сервер) Тогда
		Сервер = URL;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Порт) Тогда 
		Порт = Число(Порт);
	Иначе
		Порт = 0;
	КонецЕсли;
	
	_РазбитьСтрокуПоРазделителю(Фрагмент, Путь, "#", Истина);
	
	ПараметрыЗапроса = _ЗаполнитьПараметрыЗапроса(Путь);
	
	Если Не ЗначениеЗаполнено(Схема) Тогда
		Схема = "http";
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(Путь) Тогда
		Путь = "/";
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Аутентификация", Аутентификация);
	Результат.Вставить("Сервер", Сервер);
	Результат.Вставить("Порт", Порт);
	Результат.Вставить("Путь", Путь);
	Результат.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
	Результат.Вставить("Фрагмент", Фрагмент);

	Возврат Результат;
	
КонецФункции

Функция _РазделитьПоПервомуНайденномуРазделителю(Строка, Разделители)
	
	МинимальныйИндекс = СтрДлина(Строка);
	ПервыйРазделитель = "";
	
	Для Каждого Разделитель Из Разделители Цикл
		Индекс = СтрНайти(Строка, Разделитель);
		Если Индекс = 0 Тогда
			Продолжить;
		КонецЕсли;
		Если Индекс < МинимальныйИндекс Тогда
			МинимальныйИндекс = Индекс;
			ПервыйРазделитель = Разделитель;
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Массив;
	Если ЗначениеЗаполнено(ПервыйРазделитель) Тогда
		Результат.Добавить(Лев(Строка, МинимальныйИндекс - 1));
		Результат.Добавить(Сред(Строка, МинимальныйИндекс + СтрДлина(ПервыйРазделитель)));
		Результат.Добавить(ПервыйРазделитель);
	Иначе
		Результат.Добавить(Строка);
		Результат.Добавить("");
		Результат.Добавить(Неопределено);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция _ЗаполнитьПараметрыЗапроса(Путь)

	ПараметрыЗапроса = Новый Соответствие;
	
	Запрос = "";
	_РазбитьСтрокуПоРазделителю(Запрос, Путь, "?", Истина);
	Для Каждого СтрокаКлючРавноПараметр Из СтрРазделить(Запрос, "&", Ложь) Цикл
		СтрокаКлючРавноПараметр = РаскодироватьСтроку(
			СтрокаКлючРавноПараметр, СпособКодированияСтроки.URLВКодировкеURL);

		ПозицияРавно = СтрНайти(СтрокаКлючРавноПараметр, "=");
		Если ПозицияРавно = 0 Тогда
			Ключ = СтрокаКлючРавноПараметр;
			Значение = Неопределено;
		Иначе
			Ключ = Лев(СтрокаКлючРавноПараметр, ПозицияРавно - 1);
			Значение = Сред(СтрокаКлючРавноПараметр, ПозицияРавно + 1);
		КонецЕсли;

		Если ПараметрыЗапроса.Получить(Ключ) <> Неопределено Тогда
			Если ТипЗнч(ПараметрыЗапроса[Ключ]) = Тип("Массив") Тогда
				ПараметрыЗапроса[Ключ].Добавить(Значение);
			Иначе
				Значения = Новый Массив;
				Значения.Добавить(ПараметрыЗапроса[Ключ]);
				Значения.Добавить(Значение);
				ПараметрыЗапроса[Ключ] = Значения;
			КонецЕсли;
		Иначе
			ПараметрыЗапроса.Вставить(Ключ, Значение);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПараметрыЗапроса;

КонецФункции

Функция _РаспаковатьОтвет(Ответ)
	
	Заголовок = _ПолучитьЗначениеЗаголовка("content-encoding", Ответ.Заголовки);
	Если Заголовок <> Ложь Тогда
		Если НРег(Заголовок) = "gzip" Тогда
			Возврат _ПрочитатьGZip(Ответ.Тело);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ответ.Тело;
	
КонецФункции

Функция _ПолучитьЗначениеЗаголовка(Заголовок, ВсеЗаголовки, Ключ = Неопределено)
	
	Для Каждого ОчереднойЗаголовок Из ВсеЗаголовки Цикл
		Если НРег(ОчереднойЗаголовок.Ключ) = НРег(Заголовок) Тогда
			Ключ = ОчереднойЗаголовок.Ключ;
			Возврат ОчереднойЗаголовок.Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область Служебные

Функция КакJson(Ответ)

	Возврат _JsonВОбъект(_РаспаковатьОтвет(Ответ));
	
КонецФункции

Функция _КакJwt(Токен)  
	
	Токен_ = СтрЗаменить(Токен, "-", "+");
	Токен_ = СтрЗаменить(Токен_, "_", "/");

	МассивДанных = СтрРазделить(Токен_, ".");
	Результат = Новый Структура;
	Результат.Вставить("Заголовок", Новый Соответствие);
	Результат.Вставить("Тело", Новый Соответствие);
	
	КоличествоЭлементовТокена = 3;
	
	Если МассивДанных.Количество() <> КоличествоЭлементовТокена Тогда
		Возврат Результат;
	КонецЕсли;
		
	Результат.Заголовок = _JsonВОбъект(Base64Значение(МассивДанных[0] + _Base64Постфикс(МассивДанных[0]))); 
	Результат.Тело = _JsonВОбъект(Base64Значение(МассивДанных[1] + _Base64Постфикс(МассивДанных[1])));
	
	Возврат Результат;
	
КонецФункции

Функция _Base64Постфикс(СтрокаBase64)
	
	Результат = "";
	КоличествоСимволов = 4;
	КоличествоДополнительныхСимволов = КоличествоСимволов - (СтрДлина(СтрокаBase64) % КоличествоСимволов);

	Пока КоличествоДополнительныхСимволов > 0 Цикл
		
		Результат = Результат + "=";
		КоличествоДополнительныхСимволов = КоличествоДополнительныхСимволов - 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция _JsonВОбъект(Json, Кодировка = "utf-8", ПараметрыПреобразования = Неопределено) Экспорт
	
	ПараметрыПреобразованияJSON = _ДополнитьПараметрыПреобразованияJSON(ПараметрыПреобразования);
	
	ЧтениеJSON = Новый ЧтениеJSON;
	Если ТипЗнч(Json) = Тип("ДвоичныеДанные") Тогда
		ЧтениеJSON.ОткрытьПоток(Json.ОткрытьПотокДляЧтения(), Кодировка);
	Иначе
		ЧтениеJSON.ОткрытьПоток(Json, Кодировка);
	КонецЕсли;
	Объект = ПрочитатьJSON(
		ЧтениеJSON, 
		ПараметрыПреобразованияJSON.ПрочитатьВСоответствие,
		ПараметрыПреобразованияJSON.ИменаСвойствСоЗначениямиДата,
		ПараметрыПреобразованияJSON.ФорматДатыJSON);
	ЧтениеJSON.Закрыть();
	
	Возврат Объект;

КонецФункции

Функция _ДополнитьПараметрыПреобразованияJSON(ПараметрыПреобразования)
	
	ПараметрыПреобразованияJSON = _ПолучитьПараметрыПреобразованияJSONПоУмолчанию();
	Если ЗначениеЗаполнено(ПараметрыПреобразования) Тогда
		Для Каждого Параметр Из ПараметрыПреобразования Цикл
			Если ПараметрыПреобразованияJSON.Свойство(Параметр.Ключ) Тогда
				ПараметрыПреобразованияJSON.Вставить(Параметр.Ключ, Параметр.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ПараметрыПреобразованияJSON;
	
КонецФункции

Функция _ПолучитьПараметрыПреобразованияJSONПоУмолчанию()
	
	ПараметрыПреобразованияПоУмолчанию = Новый Структура;
	ПараметрыПреобразованияПоУмолчанию.Вставить("ПрочитатьВСоответствие", Истина);
	ПараметрыПреобразованияПоУмолчанию.Вставить("ФорматДатыJSON", ФорматДатыJSON.ISO);
	ПараметрыПреобразованияПоУмолчанию.Вставить("ИменаСвойствСоЗначениямиДата", Неопределено);
	
	Возврат ПараметрыПреобразованияПоУмолчанию;
	
КонецФункции

Функция _ОбъектВJson(Объект, Знач ПараметрыПреобразования = Неопределено, Знач ПараметрыЗаписи = Неопределено) Экспорт
	
	ПараметрыПреобразованияJSON = _ДополнитьПараметрыПреобразованияJSON(ПараметрыПреобразования);
	
	НастройкиСериализации = Новый НастройкиСериализацииJSON;
	НастройкиСериализации.ФорматСериализацииДаты = ПараметрыПреобразованияJSON.ФорматДатыJSON;
	
	ПараметрыЗаписи = _ДополнитьПараметрыЗаписиJSON(ПараметрыЗаписи);
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(
		ПараметрыЗаписи.ПереносСтрок,
		ПараметрыЗаписи.СимволыОтступа,
		ПараметрыЗаписи.ИспользоватьДвойныеКавычки,
		ПараметрыЗаписи.ЭкранированиеСимволов,
		ПараметрыЗаписи.ЭкранироватьУгловыеСкобки,
		ПараметрыЗаписи.ЭкранироватьРазделителиСтрок,
		ПараметрыЗаписи.ЭкранироватьАмперсанд,
		ПараметрыЗаписи.ЭкранироватьОдинарныеКавычки,
		ПараметрыЗаписи.ЭкранироватьСлеш);
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	ЗаписатьJSON(ЗаписьJSON, Объект, НастройкиСериализации);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

Функция _ДополнитьПараметрыЗаписиJSON(ПараметрыЗаписи)
	
	ПараметрыЗаписиJSON = _ПолучитьПараметрыЗаписиJSONПоУмолчанию();
	Если ЗначениеЗаполнено(ПараметрыЗаписи) Тогда
		Для Каждого Параметр Из ПараметрыЗаписи Цикл
			Если ПараметрыЗаписиJSON.Свойство(Параметр.Ключ) Тогда
				ПараметрыЗаписиJSON.Вставить(Параметр.Ключ, Параметр.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ПараметрыЗаписиJSON;
	
КонецФункции

Функция _ПолучитьПараметрыЗаписиJSONПоУмолчанию()
	
	ПараметрыЗаписиJSONПоУмолчанию = Новый Структура;
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ПереносСтрок", ПереносСтрокJSON.Авто);
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("СимволыОтступа", " ");
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ИспользоватьДвойныеКавычки", Истина);
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ЭкранированиеСимволов", ЭкранированиеСимволовJSON.Нет);
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ЭкранироватьУгловыеСкобки", Ложь);
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ЭкранироватьРазделителиСтрок", Истина);
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ЭкранироватьАмперсанд", Ложь);
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ЭкранироватьОдинарныеКавычки", Ложь);
	ПараметрыЗаписиJSONПоУмолчанию.Вставить("ЭкранироватьСлеш", Ложь);
	
	Возврат ПараметрыЗаписиJSONПоУмолчанию;
	
КонецФункции

Функция _КодироватьПараметрыЗапроса(ПараметрыЗапроса)
	
	ЧастиПараметрыЗапроса = Новый Массив;
	Для Каждого Параметр Из ПараметрыЗапроса Цикл
		Если ТипЗнч(Параметр.Значение) = Тип("Массив") Тогда
			Значения = Параметр.Значение;
		Иначе
			Значения = Новый Массив;
			Значения.Добавить(Параметр.Значение);
		КонецЕсли;
		
		Если Параметр.Значение = Неопределено Тогда
			ЧастиПараметрыЗапроса.Добавить(Параметр.Ключ);
		Иначе
			Для Каждого Значение Из Значения Цикл
				ЗначениеПараметра = КодироватьСтроку(Значение, СпособКодированияСтроки.КодировкаURL);
				ЧастиПараметрыЗапроса.Добавить(СтрШаблон("%1=%2", Параметр.Ключ, ЗначениеПараметра));
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(ЧастиПараметрыЗапроса, "&");
	
КонецФункции

Функция _ЗаголовкиПоУмолчанию()
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Accept-Encoding", "gzip");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded"); // TODO Этот заголовок не по умолчанию
	
	Возврат Заголовки;
	
КонецФункции

Процедура _РазбитьСтрокуПоРазделителю(ИзвлекаемаяЧасть, ОстальнаяЧасть, Разделитель, Инверсия = Ложь)
	
	Индекс = СтрНайти(ОстальнаяЧасть, Разделитель);
	Если Индекс Тогда
		ИзвлекаемаяЧасть = Лев(ОстальнаяЧасть, Индекс - 1);
		ОстальнаяЧасть = Сред(ОстальнаяЧасть, Индекс + СтрДлина(Разделитель));
		Если Инверсия Тогда
			ДляОбмена = ИзвлекаемаяЧасть;
			ИзвлекаемаяЧасть = ОстальнаяЧасть;
			ОстальнаяЧасть = ДляОбмена;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция _КлючОбъектаАвторизация()
	
	Возврат "OpneIdAuthorization_30bf15a3-4cb4-4d3e-ae68-de2af9861eeb";
	
КонецФункции

#КонецОбласти

#Область СлужебныеСтруктурыZip

// Описание структур см. здесь https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT

Функция _ПрочитатьGZip(СжатыеДанные) Экспорт
	
	РазмерПрефиксаGZip = 10;
	РазмерПостфиксаGZip = 8;
	
	ЧтениеДанных = Новый ЧтениеДанных(СжатыеДанные);
	ЧтениеДанных.Пропустить(РазмерПрефиксаGZip);
	РазмерСжатыхДанных = ЧтениеДанных.ИсходныйПоток().Размер() - РазмерПрефиксаGZip - РазмерПостфиксаGZip;
	
	ПотокZip = Новый ПотокВПамяти(ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD() + ZipРазмерCDH() + ZipРазмерEOCD());
	ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipLFH());
	ЧтениеДанных.КопироватьВ(ЗаписьДанных, РазмерСжатыхДанных);
	
	ЗаписьДанных.Закрыть();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
	
	CRC32 = ЧтениеДанных.ПрочитатьЦелое32();
	РазмерНесжатыхДанных = ЧтениеДанных.ПрочитатьЦелое32();
	ЧтениеДанных.Закрыть();
	
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipEOCD(РазмерСжатыхДанных));
	ЗаписьДанных.Закрыть();
	
	Возврат _ПрочитатьZip(ПотокZip);
	
КонецФункции

Функция _ПрочитатьZip(СжатыеДанные, ТекстОшибки = Неопределено)
	
	Каталог = ПолучитьИмяВременногоФайла();
	ЧтениеZip = Новый ЧтениеZipФайла(СжатыеДанные);
	ИмяФайла = ЧтениеZip.Элементы[0].Имя;
	Попытка
		ЧтениеZip.Извлечь(ЧтениеZip.Элементы[0], Каталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	Исключение
		// Игнорируем проверку целостности архива, просто читаем результат
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	ЧтениеZip.Закрыть();
	
	Результат = Новый ДвоичныеДанные(Каталог + ПолучитьРазделительПути() + ИмяФайла);
	УдалитьФайлы(Каталог);
	
	Возврат Результат;
	
КонецФункции

Функция ZipРазмерLFH()
	
	Возврат 34;
	
КонецФункции

Функция ZipРазмерDD()
	
	Возврат 16;
	
КонецФункции

Функция ZipРазмерCDH()
	
	Возврат 50;
	
КонецФункции

Функция ZipРазмерEOCD()
	
	Возврат 22;
	
КонецФункции

Функция ZipLFH()
	
	// Local file header
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерLFH());
	Буфер.ЗаписатьЦелое32(0, 67324752); // signature 0x04034b50
	Буфер.ЗаписатьЦелое16(4, 20); // version
	Буфер.ЗаписатьЦелое16(6, 10); // bit flags
	Буфер.ЗаписатьЦелое16(8, 8); // compression method
	Буфер.ЗаписатьЦелое16(10, 0); // time
	Буфер.ЗаписатьЦелое16(12, 0); // date
	Буфер.ЗаписатьЦелое32(14, 0); // crc-32
	Буфер.ЗаписатьЦелое32(18, 0); // compressed size
	Буфер.ЗаписатьЦелое32(22, 0); // uncompressed size
	Буфер.ЗаписатьЦелое16(26, 4); // filename legth - "data"
	Буфер.ЗаписатьЦелое16(28, 0); // extra field length
	Буфер.Записать(30, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));
	
	Возврат Буфер;
	
КонецФункции

Функция ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)
	
	// Data descriptor
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерDD());
	Буфер.ЗаписатьЦелое32(0, 134695760);
	Буфер.ЗаписатьЦелое32(4, CRC32);
	Буфер.ЗаписатьЦелое32(8, РазмерСжатыхДанных);
	Буфер.ЗаписатьЦелое32(12, РазмерНесжатыхДанных);
	
	Возврат Буфер;
	
КонецФункции

Функция ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)
	
	// Central directory header
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерCDH());
	Буфер.ЗаписатьЦелое32(0, 33639248); // signature 0x02014b50
	Буфер.ЗаписатьЦелое16(4, 798); // version made by
	Буфер.ЗаписатьЦелое16(6, 20); // version needed to extract
	Буфер.ЗаписатьЦелое16(8, 10); // bit flags
	Буфер.ЗаписатьЦелое16(10, 8); // compression method
	Буфер.ЗаписатьЦелое16(12, 0); // time
	Буфер.ЗаписатьЦелое16(14, 0); // date
	Буфер.ЗаписатьЦелое32(16, CRC32); // crc-32
	Буфер.ЗаписатьЦелое32(20, РазмерСжатыхДанных); // compressed size
	Буфер.ЗаписатьЦелое32(24, РазмерНесжатыхДанных); // uncompressed size
	Буфер.ЗаписатьЦелое16(28, 4); // file name length
	Буфер.ЗаписатьЦелое16(30, 0); // extra field length
	Буфер.ЗаписатьЦелое16(32, 0); // file comment length
	Буфер.ЗаписатьЦелое16(34, 0); // disk number start
	Буфер.ЗаписатьЦелое16(36, 0); // internal file attributes
	Буфер.ЗаписатьЦелое32(38, 2176057344); // external file attributes
	Буфер.ЗаписатьЦелое32(42, 0); // relative offset of local header
	Буфер.Записать(46, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));
	
	Возврат Буфер;
	
КонецФункции

Функция ZipEOCD(РазмерСжатыхДанных)
	
	// End of central directory
	РазмерCDH = 50;
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерEOCD());
	Буфер.ЗаписатьЦелое32(0, 101010256); // signature 0x06054b50
	Буфер.ЗаписатьЦелое16(4, 0); // number of this disk
	Буфер.ЗаписатьЦелое16(6, 0); // number of the disk with the start of the central directory
	Буфер.ЗаписатьЦелое16(8, 1); // total number of entries in the central directory on this disk
	Буфер.ЗаписатьЦелое16(10, 1); // total number of entries in the central directory
	Буфер.ЗаписатьЦелое32(12, РазмерCDH); // size of the central directory
	// offset of start of central directory with respect to the starting disk number
	Буфер.ЗаписатьЦелое32(16, ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD());
	Буфер.ЗаписатьЦелое16(20, 0); // the starting disk number
	
	Возврат Буфер;
	
КонецФункции

#КонецОбласти

#Область Запросы

Функция _ЗапросДевайсКод(Тело) Экспорт
	
	Результат = МодельЗапрос();
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	
	Результат.Хост = _ХостIdentity;
	Результат.Ресурс = _РесурсКодУстройства;
	Результат.Метод = "POST";
	Результат.Заголовки = Заголовки;
	Результат.Тело = Тело;
	
	Возврат Результат;
	
КонецФункции

Функция _ЗапросТокен(Тело) Экспорт
	
	Результат = МодельЗапрос();
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	
	Результат.Хост = _ХостIdentity;
	Результат.Ресурс = _РесурсТокен;
	Результат.Метод = "POST";
	Результат.Заголовки = Заголовки;
	Результат.Тело = Тело;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Инициализация

Функция Инит() Экспорт
	
	_Http = Новый (___Http);
	_РесурсКодУстройства = Метаданные().Реквизиты.__РесурсКодУстройства.Комментарий;
	_РесурсТокен = Метаданные().Реквизиты.__РесурсТокен.Комментарий;
	
	Возврат ЭтотОбъект;
	
КонецФункции

__Мета = Метаданные();
__Имя = __Мета.Реквизиты.__Имя.Комментарий;

___Http = __Мета.Реквизиты.___Http.Комментарий;
Если Найти(ТипЗнч(ЭтотОбъект), "Внешняя обработка объект:") Тогда
	___Http = СтрЗаменить(___Http, "ОбработкаОбъект.", "ВнешняяОбработкаОбъект.");
КонецЕсли;

Если __Имя <> __Мета.Имя Тогда
	ПространствоИмен = Лев(__Мета.Имя, СтрДлина(__Мета.Имя) - СтрДлина(__Имя));
	___Http = СтрЗаменить(___Http, ".", "." + ПространствоИмен);
КонецЕсли;

#КонецОбласти